use anyhow::Result;
use colored::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, File};
use std::path::{Path, PathBuf};

// Cache Configuration
pub const CACHE_DIR: &str = ".veghcache";
const CACHE_FILE: &str = "index.bin.zst";
const LEGACY_CACHE_FILE: &str = "index.json";

// Cache Entry Structure
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FileCacheEntry {
    pub size: u64,
    pub modified: u64,
    pub hash: Option<String>,
    #[serde(default)]
    pub chunks: Option<Vec<String>>,
}

// Main Cache Registry
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VeghCache {
    pub last_snapshot: i64,
    pub files: HashMap<String, FileCacheEntry>,
}

// FV3 Manifest Structures
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ManifestEntry {
    pub path: String,
    pub hash: String,
    pub size: u64,
    pub modified: u64,
    #[serde(default)]
    pub mode: u32, // Permissions
    #[serde(default)]
    pub chunks: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct SnapshotManifest {
    pub entries: Vec<ManifestEntry>,
}

// Construct the path to the cache file
pub fn get_cache_path(source: &Path) -> PathBuf {
    source.join(CACHE_DIR).join(CACHE_FILE)
}

// Load cache from disk. Returns a default cache if missing or corrupt.
pub fn load_cache(source: &Path) -> VeghCache {
    let cache_dir_path = source.join(CACHE_DIR);
    if !cache_dir_path.exists() {
        if let Err(e) = fs::create_dir(&cache_dir_path) {
            println!("{} Failed to create cache dir: {}", "âš ï¸".yellow(), e);
        } else {
            // [UX] Auto-generate .gitignore
            let gitignore_path = cache_dir_path.join(".gitignore");
            if !gitignore_path.exists() {
                 let content = "# Generated by Vegh\n*\n";
                 if let Err(e) = fs::write(gitignore_path, content) {
                     println!("{} Failed to create .gitignore: {}", "âš ï¸".yellow(), e);
                 }
            }
        }
    }

    let cache_path = get_cache_path(source);
    let legacy_cache_path = source.join(CACHE_DIR).join(LEGACY_CACHE_FILE);

    // 1. Try loading new binary cache
    if cache_path.exists() {
        if let Ok(file) = File::open(&cache_path) {
            if let Ok(decoder) = zstd::stream::read::Decoder::new(file) {
                 if let Ok(cache) = bincode::deserialize_from(decoder) {
                     return cache;
                 }
            }
        }
        println!("{} Binary cache corrupted or incompatible. Checking legacy...", "âš ï¸".yellow());
    }
    
    // 2. Fallback to Legacy JSON
    if legacy_cache_path.exists() {
        if let Ok(file) = File::open(&legacy_cache_path) {
            if let Ok(cache) = serde_json::from_reader(file) {
                println!("{} Loaded legacy cache. It will be upgraded on next save.", "â„¹ï¸".blue());
                return cache;
            }
        }
        println!("{} Legacy cache corrupted. Cleaning...", "ðŸ§¹".yellow());
        // Clean up corrupt cache to prevent future errors
        let _ = fs::remove_dir_all(&cache_dir_path);
    }
    
    VeghCache::default()
}

// Persist the cache state to disk
pub fn save_cache(source: &Path, cache: &VeghCache) -> Result<()> {
    let cache_dir = source.join(CACHE_DIR);
    if !cache_dir.exists() {
        fs::create_dir(&cache_dir)?;
    }
    
    let final_path = get_cache_path(source);
    let temp_path = cache_dir.join(format!("{}.tmp", CACHE_FILE));
    
    // Atomic Write: Write to temp file first
    {
        let file = File::create(&temp_path)?;
        let mut encoder = zstd::stream::write::Encoder::new(file, 0)?; // Level 0 is default
        bincode::serialize_into(&mut encoder, cache)?;
        encoder.finish()?;
    }
    
    // Rename to final path (Atomic Replace)
    fs::rename(temp_path, final_path)?;
    
    // Cleanup Legacy if it exists
    let legacy_path = source.join(CACHE_DIR).join(LEGACY_CACHE_FILE);
    if legacy_path.exists() {
        let _ = fs::remove_file(legacy_path);
    }
    
    Ok(())
}
