use anyhow::Result;
use colored::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, File};
use std::path::{Path, PathBuf};

// Cache Configuration
pub const CACHE_DIR: &str = ".veghcache";
const CACHE_FILE: &str = "index.json";

// Cache Entry Structure
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FileCacheEntry {
    pub size: u64,
    pub modified: u64,
    pub hash: Option<String>,
}

// Main Cache Registry
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VeghCache {
    pub last_snapshot: i64,
    pub files: HashMap<String, FileCacheEntry>,
}

// FV3 Manifest Structures
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ManifestEntry {
    pub path: String,
    pub hash: String,
    pub size: u64,
    pub modified: u64,
    #[serde(default)]
    pub mode: u32, // Permissions
}

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct SnapshotManifest {
    pub entries: Vec<ManifestEntry>,
}

// Construct the path to the cache file
pub fn get_cache_path(source: &Path) -> PathBuf {
    source.join(CACHE_DIR).join(CACHE_FILE)
}

// Load cache from disk. Returns a default cache if missing or corrupt.
pub fn load_cache(source: &Path) -> VeghCache {
    let cache_dir_path = source.join(CACHE_DIR);
    if !cache_dir_path.exists() {
        if let Err(e) = fs::create_dir(&cache_dir_path) {
            println!("{} Failed to create cache dir: {}", "âš ï¸".yellow(), e);
        } else {
            // [UX] Auto-generate .gitignore
            let gitignore_path = cache_dir_path.join(".gitignore");
            if !gitignore_path.exists() {
                 let content = "# Generated by Vegh\n*\n";
                 if let Err(e) = fs::write(gitignore_path, content) {
                     println!("{} Failed to create .gitignore: {}", "âš ï¸".yellow(), e);
                 }
            }
        }
    }

    let cache_path = get_cache_path(source);
    if cache_path.exists() {
        if let Ok(file) = File::open(&cache_path) {
            if let Ok(cache) = serde_json::from_reader(file) {
                return cache;
            }
        }
        println!("{} Cache corrupted. Cleaning...", "ðŸ§¹".yellow());
        // Clean up corrupt cache to prevent future errors
        let _ = fs::remove_dir_all(&cache_dir_path);
    }
    VeghCache::default()
}

// Persist the cache state to disk
pub fn save_cache(source: &Path, cache: &VeghCache) -> Result<()> {
    let cache_dir = source.join(CACHE_DIR);
    if !cache_dir.exists() {
        fs::create_dir(&cache_dir)?;
    }
    let file = File::create(get_cache_path(source))?;
    serde_json::to_writer_pretty(file, cache)?;
    Ok(())
}
